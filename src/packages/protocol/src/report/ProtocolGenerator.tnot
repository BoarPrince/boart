'use strict';

import fs from 'fs';

// ----------------------------------------------------------------------------
// Helper
// ----------------------------------------------------------------------------
class Helper {
    /**
     *
     */
    static tryParseJson(value: any): any {
        try {
            if (value === null || value === undefined) {
                return undefined;
            }

            if (Array.isArray(value)) {
                return value.map((e) => Helper.tryParseJson(e));
            } else if (value.constructor.name === 'Map') {
                const o = {};
                for (const entry of value.entries()) {
                    o[entry[0]] = Helper.tryParseJson(entry[1]);
                }
                return o;
            } else if (typeof value === 'object' && value.constructor.name === 'Object') {
                return Object.entries(value || {}).reduce((o, current) => {
                    o[current[0]] = Helper.tryParseJson(current[1]);
                    return o;
                }, {});
            } else if (typeof value === 'object') {
                return JSON.parse(Object.assign({}, value));
            } else {
                return JSON.parse(value);
            }
        } catch (error) {
            return value;
        }
    }

    /**
     *
     */
    static toJSON(self: any): string {
        const result = Object.assign({}, Helper.tryParseJson(self));
        Object.keys(result).forEach((key) => {
            if (key[0] === '_') {
                result[key.slice(1)] = result[key];
                delete result[key];
            } else {
                result[key] = Helper.tryParseJson(result[key]);
            }
        });
        return result;
    }

    /**
     *
     */
    private static zeroPad(num: number, places: number): string {
        return String(num).padStart(places, '0');
    }

    /**
     *
     */
    public static formatDate(datum: string | number): string {
        var date = new Date(datum);
        return (
            Helper.zeroPad(date.getDate(), 2) +
            '.' +
            Helper.zeroPad(date.getMonth() + 1, 2) +
            '.' +
            date.getFullYear() +
            ', ' +
            Helper.zeroPad(date.getHours(), 2) +
            ':' +
            Helper.zeroPad(date.getMinutes(), 2) +
            ':' +
            Helper.zeroPad(date.getSeconds(), 2) +
            '.' +
            date.getMilliseconds()
        );
    }

    /**
     *
     */
    public static formatDurationSec(duration: number) {
        return `${(duration / 1000).toFixed(2).replace('.', ',')} sec`;
    }

    /**
     *
     */
    public static formatDurationMin(duration) {
        return `${(duration / 1000 / 60).toFixed(2).replace('.', ',')} min`;
    }

    /**
     *
     */
    static async getFailureScreenshot(step: any): Promise<string> {
        if (!step.result.screenshot) {
            return null;
        }

        const image = await Jimp.read(Buffer.from(step.result.screenshot, 'base64'));
        const resizedImage = await image.resize(750, Jimp.AUTO);
        const base64 = await resizedImage.getBase64Async(Jimp.MIME_PNG);
        return base64;
    }

    /**
     *
     */
    static async getCustomScreenshot(step: any): Promise<string[]> {
        if (!step.result.screenshots) {
            return null;
        }

        const screenshots = [];
        for (const screenshot of step.result.screenshots) {
            const image = await Jimp.read(screenshot.filename);
            const resizedImage = await image.resize(750, Jimp.AUTO);
            const base64 = await resizedImage.getBase64Async(Jimp.MIME_PNG);
            screenshots.push(base64);
        }
        return screenshots;
    }

    /**
     *
     */
    static convertToSeconds(duration) {
        return (duration / 1000).toFixed(2).replace('.', ',');
    }

    /**
     *
     */
    static getTimeout(items) {
        return items //
            .filter((item) => !!item.result.stackTrace)
            .filter((item) => item.result.stackTrace.startsWith('Error: Timed out'))
            .map((item) => `Timeout occured after ${Helper.convertToSeconds(item.result.executionTime)} sec`)
            .find((item) => true);
    }

    /**
     *
     */
    static limitLength(value: string, maxLength: number): string {
        if (value.length > maxLength - 3) {
            return value.slice(0, maxLength) + '...';
        } else {
            return value;
        }
    }

    /**
     *
     */
    static getPriority(value: string): Priority {
        return Object.values(Priority).find((p) => p.toLowerCase() === (value || '').toLowerCase()) || Priority.Low;
    }

    /**
     *
     */
    static getStatus(value: string): Status {
        return Object.values(Status).find((p) => p.toLowerCase() === (value || '').toLowerCase()) || Status.Failed;
    }
}

/**
 *
 */
interface UIOverview {
    topic: string;
    name: string;
    ticket: string;
    status: Status;
    priority: Priority;
    duration: number;
    iteration: string;
    startTime: string;
    specId: string;
    scenarioId: string;
}

type KeyValue = { [key: string]: string };

/**
 *
 */
class UIReport {
    public durationMin: string;
    public startTimeFormatted: string;
    public projectName: string;
    public environment: string;
    private statistic = new Map<Priority, Map<Status, number>>();
    private _overview: Array<UIOverview>;
    private _specs: { [id: string]: SpecResult };
    private _scenarios: { [id: string]: UIScenarioResult };
    private _screenshots: KeyValue;

    /**
     *
     */
    private constructor() {
        this._overview = [];
        this._specs = {};
        this._scenarios = {};
        this._screenshots = {};
    }

    /**
     *
     */
    public toJSON(): string {
        return Helper.toJSON(this);
    }

    /**
     *
     */
    private static createSpecTable(specs: Array<SpecResult>): Array<UIOverview> {
        const specResult = specs.reduce(
            (uiSpec, spec) =>
                uiSpec.concat(
                    spec.scenarios.map((sc) => ({
                        topic: spec.name,
                        name: sc.name,
                        ticket: sc.tickets[0]?.id || '',
                        status: sc.status,
                        priority: sc.priority,
                        duration: sc.duration,
                        iteration: sc.iteration,
                        startTime: sc.startTime,
                        specId: spec.id,
                        scenarioId: sc.id
                    }))
                ),
            new Array<UIOverview>()
        );
        return specResult.sort((a: UIOverview, b: UIOverview) => (a.startTime > b.startTime ? 1 : -1));
    }

    /**
     *
     */
    public static create(testResult: TestResult): UIReport {
        const report = new UIReport();

        const scenarios = testResult.specs.reduce((a, c) => {
            c.scenarios.forEach((s) => a.push(s));
            return a;
        }, new Array<ScenarioResult>());

        // additional infos
        report.projectName = testResult.name;
        report.environment = testResult.environment;
        report.durationMin = Helper.formatDurationMin(scenarios.reduce((dsc, sc) => dsc + sc.duration, 0));
        report.startTimeFormatted = Helper.formatDate(
            scenarios.map((sc) => Date.parse(sc.startTime)).reduce((t, st) => (st < t ? st : t), Number.MAX_VALUE)
        );

        // filter scenarios
        testResult.specs.forEach((spec) => {
            spec.remvoeNotDescribedScenarios();
        });

        // overview
        report._overview = UIReport.createSpecTable(testResult.specs);

        // screenshots
        const reducer = (map: KeyValue, spec: SpecResult) => {
            spec.scenarios
                .flatMap((scenario) => scenario.steps)
                .map((step) => {
                    if (!step.screenshots || step.screenshots.length === 0) {
                        return;
                    }
                    const screenshots = [];
                    step.screenshots.forEach((screenshot) => {
                        const id = uuidv1();
                        screenshots.push(id);
                        map[id] = screenshot;
                    });
                    step.screenshots = screenshots;
                });
            return map;
        };
        report._screenshots = testResult.specs.reduce<KeyValue>(reducer, {});

        // create UIScenarioResult and group by id
        report._scenarios = scenarios.reduce((o, c) => {
            o[c.id] = new UIScenarioResult(c);
            return o;
        }, {} as { [id: string]: UIScenarioResult });

        // group Specs by id
        report._specs = testResult.specs.reduce((o, c) => {
            delete (c as any)._scenarios;
            o[c.id] = c;
            return o;
        }, {} as { [id: string]: SpecResult });

        // calculate statistic
        Object.keys(Priority)
            .map((p) => Priority[p])
            .map((p) => {
                report.statistic.set(p, new Map<Status, number>());
                return report.statistic.get(p);
            })
            .forEach((p) =>
                Object.keys(Status)
                    .map((s) => Status[s])
                    .forEach((s) => p.set(s, 0))
            );
        for (const sc of Object.values(report._scenarios)) {
            const prioMap = report.statistic.get(sc.priority);
            const value = prioMap.get(sc.status);
            prioMap.set(sc.status, value + 1);
        }

        return report;
    }
}

/**
 *
 */
class TestResult {
    public name: string;
    public environment: string;
    private startTime: Date;
    private endTime: Date;
    private status: Status;
    private executionTime: number;
    private _specs = Array<SpecResult>();

    /**
     *
     */
    private constructor() {}

    /**
     *
     */
    public get specs(): Array<SpecResult> {
        return this._specs;
    }

    /**
     *
     */
    public toJSON(): string {
        return Helper.toJSON(this);
    }

    /**
     *
     */
    public static async parse(jsonLog: string): Promise<TestResult> {
        const testResult = new TestResult();
        const log = JSON.parse(jsonLog);

        const scenarioMessage = (log.beforeSuiteHookMessages || [])
            .filter((m) => m.startsWith('##report##'))
            .map((m) => m.slice(10))
            .map((m) => JSON.parse(m))[0];

        testResult.name = scenarioMessage.projectName;
        testResult.environment = scenarioMessage.environment;
        testResult.startTime = log.timestamp;
        testResult.executionTime = log.executionTime;

        for (const spec of log.specResults) {
            const specResult = await SpecResult.parse(spec);
            testResult._specs.push(specResult);
        }
        return testResult;
    }
}

/**
 *
 */
class SpecResult {
    private _id = uuidv1();
    private _name: string = null;
    private _number: number = null;
    private _scenarios = Array<ScenarioResult>();

    public executionTime: number;
    public status: string;

    /**
     *
     */
    get id(): string {
        return this._id;
    }

    /**
     *
     */
    set name(value) {
        const matches = value.match(/.+--(\d+)--/);
        this._number = !!matches ? parseInt(matches[1]) : 1;
        this._name = value
            .replace(/^\d+/, this._number.toString()) // replace leading 1. with current number
            .replace(/\s+--\d+--$/, ''); // remove ending number indicator
    }

    /**
     *
     */
    public remvoeNotDescribedScenarios() {
        this._scenarios = this._scenarios.filter(
            (sc) => sc.descriptions?.length > 0 || sc.steps.some((step) => step.description?.length > 0)
        );
    }

    /**
     *
     */
    get name(): string {
        return this._name;
    }

    /**
     *
     */
    get scenarios() {
        return this._scenarios;
    }

    /**
     *
     */
    get number() {
        return this._number;
    }

    /**
     *
     */
    public toJSON(): string {
        return Helper.toJSON(this);
    }

    /**
     *
     */
    public static async parse(spec: any): Promise<SpecResult> {
        var specResult = new SpecResult();
        specResult.name = spec.specHeading;
        specResult.executionTime = spec.executionTime;
        specResult.status = Helper.getStatus(spec.executionStatus);

        for (const sc of spec.scenarios) {
            const scenario = await ScenarioResult.parse(sc, specResult.number);
            if (!!scenario) {
                specResult.scenarios.push(scenario);
            }
        }

        return specResult;
    }
}

/**
 *
 */
class ScenarioResult {
    private _id: string;
    public name: string;
    public status: Status;
    public priority: Priority;
    public tickets: Array<{ id: string; link: string; source: string }>;
    public descriptions: Array<string>;
    public failureDescription: string;
    public duration: number;
    public startTime: string;
    public iteration: string;
    public result: string;
    public payload: string;
    protected _steps = Array<StepResult>();

    /**
     *
     */
    get id(): string {
        return this._id;
    }

    /**
     *
     */
    public get steps(): Array<StepResult> {
        return this._steps;
    }

    /**
     *
     */
    protected constructor() {
        // instance cannot be created
    }

    /**
     *
     */
    public toJSON(): string {
        return Helper.toJSON(this);
    }

    /**
     *
     */
    private static flatten(arr: any): any {
        return arr.reduce((acc, cur) => acc.concat(!!cur.items ? ScenarioResult.flatten(cur.items) : cur), []);
    }

    /**
     *
     */
    public static async parse(log: any, specNumber: number): Promise<ScenarioResult> {
        const scenario = new ScenarioResult();

        scenario.name = log.scenarioHeading.replace(/^\d+/, specNumber);
        scenario.status = Helper.getStatus(log.executionStatus);
        scenario.duration = log.executionTime;

        const scenarioMessage = (log.afterScenarioHookMessages || [])
            .filter((m) => m.startsWith('##report##'))
            .map((m) => m.slice(10))
            .map((m) => JSON.parse(m))[0];

        try {
            scenario._id = scenarioMessage.id;

            const scenarioMessageContent = JSON.parse(fs.readFileSync(scenarioMessage.filename, 'utf-8'));
            scenario.startTime = scenarioMessageContent?.startTime;
            scenario.priority = Helper.getPriority(scenarioMessageContent?.priority || 'low');
            scenario.descriptions = scenarioMessageContent?.descriptions;
            scenario.tickets = scenarioMessageContent?.tickets || [];
            scenario.iteration = scenarioMessageContent?.iteration || '';
        } catch (error) {
            throw new Error(
                `can't read scenario file: '${scenarioMessage.filename}', name: ${scenario.name}\n${Helper.tryParseJson(error)}`
            );
        }

        let number = 1;
        for (const item of ScenarioResult.flatten(log.items)) {
            const step = await StepResult.parse(item);
            if (!!step) {
                step.description = step.description?.map((d) => `${number++}. ${d}`);
                scenario.steps.push(step);
            }
        }

        return scenario;
    }
}

/**
 *
 */
class UIScenarioResult extends ScenarioResult {
    private durationSec: string;
    private startTimeFormatted: string;
    private errorMessage: string;

    /**
     *
     */
    public toJSON(): string {
        return Helper.toJSON(this);
    }

    /**
     *
     */
    constructor(scenario: ScenarioResult) {
        super();
        Object.assign(this, scenario);

        this.durationSec = Helper.formatDurationSec(this.duration);
        this.startTimeFormatted = Helper.formatDate(this.startTime);

        this.errorMessage = this._steps.find((s) => s.status === Status.Failed)?.errorMessage;

        this._steps = this._steps.map((s) => new UIStepResult(s));
    }
}

/**
 *
 */
class StepResult {
    private _id: string;
    public type: string;
    public status: Status;
    public description: Array<string>;
    public duration: number;
    public startTime: string;
    public input: any;
    public output: any;
    public screenshots: Array<any>;
    public errorMessage: string;

    /**
     *
     */
    protected constructor() {
        this.screenshots = [];
    }

    /**
     *
     */
    get id(): string {
        return this._id;
    }

    /**
     *
     */
    public toJSON(): string {
        return Helper.toJSON(this);
    }

    /**
     *
     */
    public static async parse(log: any): Promise<StepResult> {
        const step = new StepResult();
        step.status = Helper.getStatus(log.result.status);
        step.errorMessage = log.result.stackTrace || log.result.errorMessage;
        step.duration = log.result.executionTime;

        const reportMessage = (log.afterStepHookMessages || [])
            .filter((m) => m.startsWith('##report##'))
            .map((m) => m.slice(10))
            .map((m) => JSON.parse(m))[0];

        if (!reportMessage) {
            if (!!step.errorMessage) {
                step.description = ['Error occured'];
                step.input = [];
                step.output = [];
                return step;
            } else {
                return null;
            }
        }

        try {
            step._id = reportMessage.id;

            const stepMessageContent = JSON.parse(fs.readFileSync(reportMessage.filename, 'utf-8'));
            step.startTime = stepMessageContent.startTime;
            step.type = new String(stepMessageContent.type).toLowerCase();
            step.description = stepMessageContent.description;

            step.input = Helper.tryParseJson(stepMessageContent.input);
            step.output = Helper.tryParseJson(stepMessageContent.result);

            const screenshots = await Helper.getCustomScreenshot(stepMessageContent);
            if (!!screenshots) {
                screenshots.forEach((screenshot) => step.screenshots.push(screenshot));
            }
        } catch (error) {
            throw new Error(`can't read step file: ${reportMessage.filename}\n${Helper.tryParseJson(error)}`);
        }

        return step;
    }
}

/**
 *
 */
class UIStepResult extends StepResult {
    public durationSec: string;
    public startTimeFormatted: string;

    /**
     *
     */
    constructor(scenario: StepResult) {
        super();
        Object.assign(this, scenario);
        this.durationSec = Helper.formatDurationSec(this.duration);
        this.startTimeFormatted = Helper.formatDate(this.startTime);

        const formatDate = (arrayOfDateObjects: Array<any>): any => {
            return arrayOfDateObjects?.map((a) => {
                a.date = Helper.formatDate(a.date);
                return a;
            });
        };

        switch (this.type) {
            case 'restcall':
                if (!!this.input.data?.option?.agent) {
                    delete this.input.data.option.agent;
                }
                this.input = [
                    {
                        desc: this.input.desc,
                        data: this.input.data
                    },
                    {
                        desc: 'Rest call (curl)',
                        type: 'text',
                        data: this.input.curl
                    }
                ];
                break;
            case 'bearerrequesting':
                this.input = [
                    {
                        desc: this.input.desc,
                        data: this.input.data
                    },
                    {
                        desc: 'Rest call (curl)',
                        type: 'text',
                        data: this.input.curl
                    }
                ];
                break;
            case 'queueconsuming': {
                this.input.data?.forEach((d) => (d.receivedTime = Helper.formatDate(d.receivedTime)));
                this.input = [
                    {
                        desc: 'Parameters',
                        data: this.input.config
                    },
                    {
                        desc: this.input.desc,
                        data: this.input.data
                    }
                ];
                break;
            }
            case 'uiopenpage':
                this.output.data = {
                    console: formatDate(this.output.console),
                    restcall: formatDate(this.output.restcall)
                };
                break;
            case 'uidoactions':
                this.input.data = this.input['ui-action'].map((a) => {
                    if (a.error?.length === 0) {
                        a.error = undefined;
                    }
                    if (a.restCalls?.length === 0) {
                        a.restCalls = undefined;
                    }
                    if (Object.keys(a.context).length === 0) {
                        a.context = undefined;
                    }
                    a.duration = Helper.formatDurationSec(a.endTime - a.startTime);
                    a.startTime = undefined;
                    a.endTime = undefined;
                    return a;
                });

                // parse rest calls
                const restcalls = new Array<any>();
                for (const action of this.input.data) {
                    const restcallUrls = new Array<any>();
                    for (const filename of action?.restCalls || []) {
                        const restCall = JSON.parse(fs.readFileSync(filename, 'utf-8'));
                        restcallUrls.push(restCall.url + restCall.query);
                        delete restCall.id;
                        restCall.duration = Helper.formatDurationSec(restCall.startTime);
                        restCall.startTime = Helper.formatDate(restCall.startTime);
                        restCall.endTime = Helper.formatDate(restCall.endTime);
                        restcalls.push(restCall);
                    }
                    action.restCalls = restcallUrls.length != 0 ? restcallUrls : undefined;
                }

                const descExt = new Array<string>();
                if (restcalls.length > 0) {
                    descExt.push(`${restcalls.length} Rest calls`);
                }
                if (this.screenshots.length > 0) {
                    descExt.push(`${this.screenshots.length} Screenshots`);
                }
                if (descExt.length > 0) {
                    this.description[0] += ` (${descExt.join(', ')})`;
                }

                this.output = [
                    {
                        desc: 'Console output',
                        type: 'console',
                        data: formatDate(this.output.console)
                    },
                    {
                        desc: 'Rest calls',
                        type: 'restcalls',
                        data: restcalls
                    }
                ];
                break;
            default:
            // do nothing
        }

        if (!Array.isArray(this.input)) {
            // input must always be an array
            this.input = [
                {
                    desc: this.input.desc,
                    data: this.input.data
                }
            ];
        }
        this.input?.forEach((data) => (data.id = uuidv1()));

        if (!Array.isArray(this.output)) {
            // input must always be an array
            this.output = [
                {
                    desc: this.output.desc,
                    data: this.output.data
                }
            ];
        }
        this.output?.forEach((data) => (data.id = uuidv1()));
    }
}

// ----------------------------------------------------------------------------
// Main
// ----------------------------------------------------------------------------
const fileContents = fs.readFileSync('gauge/.reports/json-report/result.json', 'utf-8');
TestResult.parse(fileContents).then((testResult) => {
    fs.writeFile('gauge/.reports/testResult.json', JSON.stringify(testResult, null, ' '), 'utf-8', (writeErr) => {
        if (writeErr) return console.log(writeErr);
    });

    const result = UIReport.create(testResult);

    fs.writeFile('gauge/.reports/result_for_html.json', JSON.stringify(result, null, ' '), 'utf-8', (writeErr) => {
        if (writeErr) return console.log(writeErr);
    });

    fs.readFile('src/protocol_generator/template.html', 'utf-8', (err, fileContents: string) => {
        if (err) throw err;
        const htmlContent = fileContents.replace('${protocol_data}', JSON.stringify(result));

        fs.writeFile('gauge/.reports/test-protocol.html', htmlContent, 'utf-8', (writeErr) => {
            if (writeErr) return console.log(writeErr);
        });
    });
});
